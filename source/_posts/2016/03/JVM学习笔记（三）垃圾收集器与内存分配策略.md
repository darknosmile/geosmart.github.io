title: JVM学习笔记（三）垃圾收集器与内存分配策略
date: 2016-03-09 21:07:52
tags: [Java,JVM]
categories: [读书笔记]
---
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。
- - -
<!-- more -->

# 概述
垃圾收集（Garbage Collection，GC）需要完成的三件事情：
1. 哪些内存需要回收？  
-[] 内存区域-回收条件
2. 什么时候回收？  
-[] 多线程/安全点
3. 如何回收？
-[] 回收算法

当要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些"自动化"的技术实施必要的监控和调节。
1. `程序计数器、虚拟机栈、本地方法栈`3个区域随线程而生，随线程而灭；每一个栈帧中分配多少内存基本上在类结构确定下来的时候就已知。因此这几个区域的内存分配和回收都具有确定性，不需过多考虑回收问题，方法结束或者线程结束时，内存自然就随之回收了。
2. `Java堆和方法区`则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间才知道会创建哪些对象，这部分内存的分配和回收都是`动态`的，垃圾收集器所关注的是这部分内存！

---
# 对象已死吗？
垃圾回收器在对堆进行回收前，首要确定的事情就是这些对象之间哪些还`存活`着，哪些已经`死去`？
## 引用计数算法
* 定义：引用计数算法（`Reference Counting`）:给对象添加一个引用计数器，每当一个地方引用它时，计数器值就+1；当引用失效时，计数器值就-1；任何时刻计数器为0的对象就是不可能被再使用的；
* 优点：实现简单，判定效率高；微软的COM技术、Python中都使用了Reference Couting算法进行内存管理；
* 缺点：由于其很难解决对象之间相互循环引用的问题，主流Java虚拟机里面都没有选用Refrence Couting算法来管理内存；

## 可达性分析算法
* 定义：可达性分析（`Reachability Analysis`）判断对象存活的基本思路：通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连（即GC Roots到这个对象不可达）时，则证明此对象是不可用的；
![可达性分析算法](可达性分析算法.png)
* Java语言中，可作为GC Roots对象包括：
1. 虚拟机栈（栈帧中的本地变量表）中引用的对象；
2. 方法区中类静态属性引用的对象；
3. 方法区中产量引用的对象；
4. 本地方法栈中JNI（即一般的Native方法）引用的对象

## 再谈引用
JDk1.2之后，Java对引用概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，4种强度一次逐渐减弱。
1. 强引用（`Strong Reference`）是指在程序代码之中普遍存在的，类似`Object obj=new Object()`这类的引用，只要强引用存在，对象就不会发生GC；
2. 软引用（`Soft Reference`）是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生OOM异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出OOM异常。
3. 弱引用（`Weak Reference`）是用来描述非必须对象的，强度比软引用更弱，被弱引用关联的对象只能生存到下一次GC发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
4. 虚引用（`Phantom Reference`）也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

## 回收方法区
* 在方法区中进行垃圾收集的性价比一般比较低；而在Heap中，尤其是在新生代，常规应用进行一次垃圾收集一般回收70%~95%的空间，而永久代的垃圾收集效率远低于此；
* 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类；
* 回收废弃常量与回收Java堆中的对象类似；
* 判定一个类是否是无用的类条件相对苛刻：
  * 该类所有实例都已被回收，即Java堆中不存在该类的任何实例；
  * 加载该类的`ClassLoader`已经被回收；
  * 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该方法。

__在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出__。

---
# 垃圾收集算法
只介绍算法思想及发展过程，不讨论具体算法实现
## 标记-清除算法（Mak-Sweep）
* 定义：MS算法分标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
![标记-清除算法示意图](标记-清除算法示意图.png)
* 两点不足：
  * 效率问题，标记和清除两个过程的效率都不高；
  * 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多后导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发一次垃圾收集动作；

## 复制算法（Coping）
* 定义：Coping算法将可用内存按容量划分为大小相等的两块，每次使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用的内存清理掉。
![复制算法示意图](复制算法示意图.png)
* 优点：每次对整个半区进行回收，内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效；
* 不足：提高效率的代价是将内存缩小到原来的一半；
现代商业虚拟机都采用这种收集算法来回收新生代，但新生代中的对象一般98%是`朝生夕死`，无需按照1:1比例来划分内存空间，而是将内存分为1块较大的Eden（伊甸园）空间和2块较小的Survivor（幸存者）空间，每次使用Eden和其中1块Survivor。
* 回收时，将Eden和Survivor中还存活的对象一次性复制到另外一个Survivor空间中，最后清理掉Eden和刚才用过的Survivor空间。
* HotSpot VM默认Eden和Survivor的比例是8:1:1，即只浪费10%的内存。
* 98%的对象可回收只是一般场景下的数据，无法保证每次回收都只有不多于10%的对象存活，所以当Survivor空间不足时，需要依赖其他内存（老年代）进行`分配担保（Handle Promotion）`，让对象进入老年代。

## 标记-整理算法（Mark-Compact）
* 出场背景：复制算法在对象存活率较高时复制操作较多，效率会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以对应被使用内存中的所有对象都100%存活的极端情况，所以老年代一般不直接选用这种算法。
* 定义：根据老年代的特点，提出标记-整理（Mark-Compact）算法，标记过程仍然与`标记-清除`算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理调用端边界以外的内存。
![标记-整理算法](标记-整理算法.png)
* 内存碎片整理
  ![内存碎片整理](内存碎片整理.png)
* 标记-清除算法 vs 标记-整理算法
  ![mark_sweep_vs_mark_compact](mark_sweep_vs_mark_compact.png)

## 分代收集算法
当前商业虚拟机的垃圾收集都采用`分代收集`(Generational Collection)算法，根据对象存活周期的不同将内存分为几块。
* 一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法；
* 新生代每次垃圾回收时都发现有大批对象死去,只有`少量对象存活`，故采用`复制`算法，以少量对象复制的成本即可完成收集；
* 老年代中因为`对象存活率高`、没有额外空间对其进行分配担保，必须采用`标记-清理`或`标记-整理`算法来进行回收。
---
# HotSpot的算法实现

## 枚举根基点
## 安全点
## 安全区域
---
# 垃圾收集器
## Serial收集器
## ParNew收集器（Parallel New）
## Parallel Scavenge收集器
## Serial Old收集器
## Parallel Old收集器
## CMS收集器（Concurrent Mark Sweep）
## G1收集器（Garbage-First）
## 理解GC日志
## 垃圾收集器参数总结
---
# 内存分配与回收策略
## 对象优先在Eden分配
## 大对象直接进入老年代
## 长期存活的对象将进入老年代
## 动态对象年龄判定
## 空间分配担保
